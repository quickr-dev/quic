---
- name: Quic Base System Setup
  hosts: localhost
  become: yes
  gather_facts: yes
  vars:
    quicd_target_path: "/usr/local/bin/quicd"
    cert_path: "/etc/quic/certs"
    tank_data_dir: "/tank/data"
    quicd_grpc_port: "8443"
    # Required user-provided vars
    zfs_devices: '{{ zfs_devices | mandatory(''Please provide ZFS devices, e.g. -e zfs_devices="[nvme0n1,nvme1n1]"'') }}'
    cert_email: '{{ cert_email | mandatory(''Please provide cert email, e.g. -e cert_email="your@email.com"'') }}'
    cert_domain: '{{ cert_domain | mandatory(''Please provide cert domain, e.g. -e cert_domain="your.domain.com"'') }}'
    pg_version: "{{ pg_version | mandatory('Please provide postgresql version, e.g. -e pg_version=16') }}"

  tasks:
    # ===============================================
    # Firewall Setup
    # ===============================================
    - name: Open required firewall ports
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - "22" # SSH
        - "80" # HTTP for Let's Encrypt
        - "{{ quicd_grpc_port }}"

    - name: Ensure UFW is enabled
      ufw:
        state: enabled

    # ===============================================
    # Package Installation
    # ===============================================
    - name: Update package cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install required packages
      apt:
        name:
          - zfsutils-linux
          - "postgresql-{{ pg_version }}"
          - postgresql-contrib
          - pgbackrest
        state: present

    - name: Stop and disable default PostgreSQL service
      systemd:
        name: postgresql
        state: stopped
        enabled: false

    # ===============================================
    # Let's Encrypt Setup
    # ===============================================
    - name: Check if TLS certificates exist
      stat:
        path: "{{ cert_path }}/server.crt"
      register: cert_exists

    - name: Let's Encrypt Setup
      when: not cert_exists.stat.exists
      block:
        - name: Install certbot and nginx
          apt:
            name:
              - certbot
              - python3-certbot-nginx
              - nginx
            state: present

        - name: Create nginx config for Let's Encrypt validation
          copy:
            content: |
              server {
                  listen 80;
                  server_name {{ cert_domain }};

                  location /.well-known/acme-challenge/ {
                      root /var/www/certbot;
                  }

                  location / {
                      return 301 https://$server_name$request_uri;
                  }
              }
            dest: /etc/nginx/sites-available/letsencrypt
            mode: "0644"

        - name: Enable nginx site
          file:
            src: /etc/nginx/sites-available/letsencrypt
            dest: /etc/nginx/sites-enabled/letsencrypt
            state: link

        - name: Remove default nginx site
          file:
            path: /etc/nginx/sites-enabled/default
            state: absent

        - name: Create certbot webroot directory
          file:
            path: /var/www/certbot
            state: directory
            mode: "0755"

        - name: Start nginx for Let's Encrypt validation
          systemd:
            name: nginx
            state: restarted
            enabled: yes

        - name: Obtain Let's Encrypt certificate
          command: |
            certbot certonly --webroot -w /var/www/certbot -d {{ cert_domain }}
            --non-interactive --agree-tos --email {{ cert_email }}
          args:
            creates: /etc/letsencrypt/live/{{ cert_domain }}/fullchain.pem

        - name: Create TLS certificate directory for quicd
          file:
            path: "{{ cert_path }}"
            state: directory
            owner: quic
            group: postgres
            mode: "0755"

        - name: Copy Let's Encrypt certificates for quicd
          copy:
            src: "{{ item.src }}"
            dest: "{{ item.dest }}"
            owner: quic
            group: postgres
            mode: "{{ item.mode }}"
            remote_src: yes
          loop:
            - {
                src: "/etc/letsencrypt/live/{{ cert_domain }}/fullchain.pem",
                dest: "{{ cert_path }}/server.crt",
                mode: "0644",
              }
            - {
                src: "/etc/letsencrypt/live/{{ cert_domain }}/privkey.pem",
                dest: "{{ cert_path }}/server.key",
                mode: "0640",
              }

        - name: Setup auto-renewal cron job
          cron:
            name: "Let's Encrypt renewal"
            minute: "0"
            hour: "3"
            job: "certbot renew --quiet --post-hook 'cp /etc/letsencrypt/live/{{ cert_domain }}/fullchain.pem {{ cert_path }}/server.crt && cp /etc/letsencrypt/live/{{ cert_domain }}/privkey.pem {{ cert_path }}/server.key && chown quic:postgres {{ cert_path }}/* && systemctl restart quicd'"

    # ===============================================
    # System Setup
    # ===============================================
    - name: Create quic system user
      user:
        name: quic
        system: yes
        shell: /bin/false
        home: /var/lib/quic
        create_home: yes
        groups: postgres
        append: yes

    - name: Create Quic log directory
      file:
        path: "/var/log/quic"
        state: directory
        owner: quic
        group: quic
        mode: "0755"

    - name: Setup quic user sudoers permissions for system operations
      copy:
        content: |
          # Quic agent permissions for system operations
          quic ALL=(ALL) NOPASSWD: /sbin/zfs, /sbin/zpool, /usr/sbin/ufw, /bin/kill, /usr/bin/pgrep, /bin/rm, /bin/systemctl, /usr/bin/tee
          # Allow quic to run postgres commands as postgres user
          quic ALL=(postgres) NOPASSWD: /usr/lib/postgresql/*/bin/*, /bin/sh
        dest: /etc/sudoers.d/quic-agent
        mode: "0440"
        validate: "visudo -cf %s"

    - name: Ensure /etc/quic directory exists
      file:
        path: /etc/quic
        state: directory
        owner: quic
        group: postgres
        mode: "0755"

    # ===============================================
    # ZFS Encryption Setup
    # ===============================================
    - name: Generate ZFS encryption key
      command: openssl rand -out /etc/quic/zfs-key 32
      args:
        creates: /etc/quic/zfs-key

    - name: Set ZFS key permissions
      file:
        path: /etc/quic/zfs-key
        owner: root
        group: root
        mode: "0600"

    - name: Check if tank pool exists and is encrypted
      shell: zpool status tank && zfs get encryption tank
      register: tank_status
      failed_when: false
      changed_when: false

    - name: Display tank encryption status
      debug:
        msg: "Tank pool status: {{ 'exists' if tank_status.rc == 0 else 'does not exist' }} | Encryption: {{ 'enabled' if 'aes' in tank_status.stdout else 'disabled' }}"

    - name: Set up encrypted tank pool if needed
      block:
        - name: Build ZFS device list
          set_fact:
            zfs_device_list: "{{ zfs_devices | map('regex_replace', '^(.*)$', '/dev/\\1') | join(' ') }}"

        - name: Create encrypted tank pool
          shell: |
            zpool create tank {{ zfs_device_list }} \
              -O encryption=aes-256-gcm \
              -O keylocation=file:///etc/quic/zfs-key \
              -O keyformat=raw
            zfs set recordsize=8K tank
            zfs set compression=lz4 tank
            zfs set atime=off tank
            zfs set logbias=throughput tank
          args:
            creates: /tank

        - name: Set postgres ownership on tank pool
          command: chown postgres:postgres /tank

        - name: Create data directory in tank
          file:
            path: "{{ tank_data_dir }}"
            state: directory
            owner: postgres
            group: postgres
            mode: "0700"
      when: tank_status.rc != 0 or 'aes' not in tank_status.stdout

    - name: Create ZFS auto-unlock service
      copy:
        content: |
          [Unit]
          Description=Auto-unlock encrypted ZFS datasets
          After=zfs-import.target
          Before=postgresql.service quicd.service

          [Service]
          Type=oneshot
          ExecStart=/bin/bash -c 'zfs load-key -a 2>/dev/null || true; zfs mount -a'
          User=root
          RemainAfterExit=yes

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/zfs-unlock.service
        mode: "0644"

    - name: Enable ZFS unlock service
      systemd:
        name: zfs-unlock
        enabled: yes
        daemon_reload: yes

    # ===============================================
    # Quicd Installation
    # ===============================================
    - name: Download latest quicd binary from GitHub releases
      get_url:
        url: "https://github.com/quickr-dev/quic/releases/latest/download/quicd-linux-amd64"
        dest: "{{ quicd_target_path }}"
        owner: root
        group: root
        mode: "0755"
        force: yes
      notify: restart quicd

    # ===============================================
    # Systemd Services
    # ===============================================
    - name: Create Quic gRPC systemd service
      copy:
        content: |
          [Unit]
          Description=Quicd
          Documentation=https://github.com/quickr-dev/quic
          After=network.target zfs-unlock.service

          [Service]
          Type=simple
          User=quic
          WorkingDirectory=/tank
          ExecStart={{ quicd_target_path }}
          Restart=always
          RestartSec=5
          StandardOutput=journal
          StandardError=journal

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/quicd.service
        mode: "0644"
      notify: restart quicd

    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes

    - name: Enable and start quicd service
      systemd:
        name: quicd
        state: started
        enabled: yes

  handlers:
    - name: restart quicd
      systemd:
        name: quicd
        state: restarted
        daemon_reload: yes
